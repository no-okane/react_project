# react (2025-06-18~)
### node js
- 서버 : 네트워크를 통해 클라이언트에 정보 또는 서비스 제공하는 컴퓨터 또는 프로그램
- 클라이언트 : 요청 보내는 주체(브라우저 데톱 프로그램 모바일 앱 다른 서버 등)
------
### 자바스크립트 런타임 node js
- 런타임 : 특정 언어로 만든 프로그램을 실행할 수 있는 환경
-----
### 블로킹/논블로킹
- 블로킹 : 이전 작업이 끝날 때까지 기다린 다음, 다음 작업 진행
- 논블로킹 : 이전 작업이 끝날 때까지 기다리지 않고 다음 작업 먼저 진행 -> 항상 논블로킹 방식으로 코딩
-----
### 스레드
- 프로세스 내에서 작업을 수행하는 최소 단위, 실행의 흐름 개념
- 다양한 개발환경에선 성능, 안전성 문제 포함 멀티 프로세싱 방식 선호
-----
### SSR (server side rendering)
- 서버에서 HTML을 미리 생성하여 클라이언트에 전달하는 방식
- 브라우저가 html을 받자마자 렌더링 할 수 있어 초기 로딩 속도 빠름
- 매 요청마다 html을 생성하여 서버 부하 발생 가능성 높음
- 대표적 ssr 프로그래밍 언어 : next.js
### CSR (client-side rendering)
- 브라우저가 최초 로드 시 빈 html, js 파일을 불러와 화면을 렌더링하는 방식
- 빠른 페이지 이동, 서버 부하 적음, 비동기 데이터 요청 사용
- 대표적인 csr 프로그래밍 언어 : react, vue
### SPA (single page application)
- 하나의 html 파일에서 js 활용하여 동적으로 페이지 변경
- 전체 페이지를 새로고침하지 않고 클라이언트에게 필요한 화면만 변경
- 빠른 페이지 전환, 부드러운 사용자 경험, 모바일 앱과 유사한 uiux기능
- 대표적인 spa 프로그래밍 언어 : react, vue, angular
-----
### react 개발환경설정 vite+react
```
리액트 설치 명령어
npm create vite@latest 생성프로젝트명 -- --template react
cd 프로젝트명 (나올 때는 cd ..)
npm install
npm run dev
```
```
리액트 폴더 삭제명령어(평균 10~20초 정도 소요됨)
rm -r 삭제폴더명
```
-----
### 바이트+리액트 설치 후 폴더와 파일 구조
- public, src/assets : 이미지, 동영상, 폰트 등 외부 파일 관리
- src : css, jsx(js xml 약자로 리액트용 js 확장 문법) 파일 관리
- index.html : 최상위 (root)에 존재하며 기본 위치에서 이동 금지
- gitignore : 깃허브 업로드 시 업로드 안 되는 보호 파일 목록
- package.json, vite.config.js : 리액트 관련 설치 정보 및 세팅 정보
-----
### jsx 파일 생성 후 다른 jsx 파일에 연결하는 방법
- `App.jsx` 파일 생성 후 `Main.jsx`파일에 연결하고 싶을 때
    - `Main.jsx`의 시작 줄에서 `import` 방식으로 외부 jsx 파일 연결
        - `import 컴포넌트명 from 'jsx상대경로'`
        - 컴포넌트명은 jsx 파일의 이름과 동일하게 작성
        - import의 컴포넌트명은 앞으로 이 이름을 쓰게다는 뜻의 변수 선언과 같으며 호출은 별도 진행
    - import 진행 후 원하는 렌더링 위치에 `<컴포넌트명 />`작성
        - `import App from '.App.jsx'`라면 `<App />`라고 작성
    - `Main.jsx`에서 컴포넌트로 연결한 `App.jsx`가 정상적으로 출력되며 리액트 프로그래밍 진행
------
### JSX
- 자바스크립트 html 태그를 직접 사용하는 문법
- 상수 선언 후 렌더링
- 장점 : 보기 쉽고 활용도 높음
- 원시 자료형 (숫자, 문자 논리, null, undfined)를 제외한 값 사용하면 오류 발생
- jsx 문법
    - jsx에서는 닫기 태그 없어도 닫기 태그 표시 : `<br />` `<img />``<input />`
    - jsx가 반환하는 모든 태그는 최상위 태그로 감싸야 함 -> 자식 태그는 1개
    - html 태그를 최상위로 사용하지 않으려면 `<React.Fragment> </React.Fragment>` 사용 또는 빈태그 `<> </>` 사용
- jsx 기본 모습, 템플릿
```

import 외부 파일 불러오는 위치

function 컴포넌트명() {
    추가변수 작성 위치

    return (
    <>
        추가 html 태그 작성 위치
    </>
    )
}

export default 컴포넌트명;

```
- 스타일 작성법
    - 인라인 스타일링
    - 외부 스타일링
- 컴포넌트 함수 적용과 관리
    - 리액트 컴포넌트는 자바스크립트의 클래스와 함수 이용
    - 컴포넌트 함수의 첫 글자는 영어 대문자
    - 기본 함수 선언 : `function 함수명(){return(<태그명>);};`
    - 화살표 함수 선언 : `const 함수명 = () => {return (태그명);};`
    - 

-----
### 컴포넌트
- 여러 개의 컴포넌트를 조합하여 전체 애플리케이션 구성
- 재사용 높음, 단순한 코드, 쉬운 유지보수
- 함수형 컴포넌트를 주로 사용
- 대문자로 시작, <컴포넌트명 />형태로 호출
- 컴포넌트 함수의 첫 글자는 대문자로 작성
- 함수형 컴포넌트
    - 자바스크립트 함수처럼 동작하는 컴포넌트
    - 리턴 사용, jsx 반환
    - html 태그처럼 사용 가능
    - 여러번 렌더링 가능

-----
### props
- 부모-자식 컴포넌트 사이에서 데이터 전달하는 방법
- 부모 (상위 컴포넌트)-자식(하위 컴포넌트)
    - 부모가 자식에게 선물(값) 전달
    - 자식은 부모에게 받은 선물(값) 바꿀 수 없음

-----
### Router
- 페이지 새로고침없이 ui 변경하는 spa로 동작
- 새로고침없이 여러 페이지를 이동할 수 있도록 도와주는 훅(hook, 도구) = 라우터
- 브라우저 히스토리 관리 (뒤로, 앞으로 이동 가능)
- 리액트의 컴포넌트 단위로 나누는 화면 특징을 이용해 컴포넌트를 페이지처럼 관리
- 페이지를 찾을 수 없을때 404페이지로 대체 화면 보여주기 가능
- BrowerRouter : 브라우저 히스토리 기반으로 동작하는 라우터 (최상위 컴포넌트)
- Routes : 여러 개의 Route 감싸는 컨테이너 (부모)
- Route : 특정 경로에 대해 렌더링할 컴포넌트 지정
- Link : 새로고침없이 다른 페이지로 이동하는 경로 태그
- Navigate : 특정 조건에 따라 리디렉션 수행, 권한이 없는 페이지 또는 로그인/로그아웃에 따라 페이지 이동 시

----- 
### useState 개념
- 데이터 값을 저장하고 상황에 따라 변경할 수 있게 도와주는 상태곤리 훅(도구)
- `import {useState} from 'react'`
- 입력 폼 데이터 관리, 화면 표시-숨김 토글 기능, 쇼핑몰 상품 수량 증감, 쇼핑몰 선택한 상품이 장바구니에 담기는 기능, 할 일 목록/장바구니목록/ 호원 정보 등 데이터 관리

-----
### UseRef
- 값의 변경이 일어날 시 사용자가 보는 화면 ui에 업데이트가 즉시 일어나는 시각적인 형태
- 참조 개념, dom 요소의 값을 가져오거나 변경할 때 또는 리렌더링없이 값을 저장하고 싶을 때 유용
- 참조나 렌더링 간에 유지되어야 하는 값 저장
```
import { useRef } from "react"
const 변수명 = useRef(초기값);
return (<p ref={변수명}>이 요소를 참조할거야!</p>) // 변수명.current.변경메서드 및 속성
```

-----
### API
- 웹사이트가 서버(db)에서 최신 정보 가져오는 과정
- 날씨, 유튜브, 쇼핑몰 앱은 api 호출 통해 최신 데이터 표시
- 프론트엔드는 api 호출 통해 백엔드 서버에서 데이터 가져옴
- api는 웹사이트에 동적인 정보 제공 필수 사용자가 항상 최신 정보 제공 받음
- http 요청 방식 (method)
    - get : 데이터 가져올 때 사용 (뉴스 목록 불러오기)
    - post : 새로운 데이터 보낼 때 사용 (회원가입)
    - put : 기존 데이터 수정 (프로필 수정)
    - delete : 데이터 삭제 (댓 삭)
- **json**(javascript objext notation)
    - 서버에서 프론트엔드로 데이터를 보낼 때 사용하는 표준 형식
    - 자바스크립트 객체와 비슷함
    - 텍스트 기반, 데이터 전송이 빠르고 용량이 작아 효율적
- 비동기 방식 비교
    - async / await + rty / catch
        - 코드가 순차적으로 읽힘
        - 에러 처리가 직관적
        - 최신 인기 방식으로 디버깅 쉬움
        - async함수(비동기 함수)+await (promise 객체가 완료될 때까지 기다리는 함수 키워드)
        - promise : 지금은 데이터 없지만 나중에 데이터 준다는 뜻의 객체
    - fetch() then()
        - 콜백 지옥 위험 있음
        - 코드가 복잡해보이고 에러 처리가 분산되는 단점

-----
### useEffect
- 마운트 (mount 탄생) : 컴포넌트 페이지 처음 렌더링 할 때
- 업데이트(update 갱신) : state 또는 props 값이 바뀌거나 부모가 리렌더링 되어 자식도 리렌더링 될 때
- 언마운트(unmount 사망) : 더이상 페이지에 컴포넌트를 렌더링하지 않을 때, 컴포넌트 값 변경 후 기존 값 정리
- useeffect 렌더링 함수 : 컴포넌트가 렌더링 될 때 실행되는 함수
    - 마운트 : 컴포넌트 초기 렌더링 시 한 번만 실행
        - `useEffect ( () => {실행코드}, [] )`
    - 업데이트 : zjavhsjsxmdml state props ref 등의 값이 변경 될 때마다 실행
        - `useEffect ( () => {실행코드}, [의존성 배열] )`
    - 언마운트 또는 클린업 함수 : 컴포넌트가 화면에서 사라질 때 값이 바뀌 때 정리용 실행
        - `useEffect ( () => {실행코드 return () => { 언마운트코드 }}, [의존성 배열] )`